SECTION .BSS
	BUFF RESB 1

SECTION .DATA

SECTION .TEXT
	GLOBAL _START

_START:
	NOP            ; THIS NO-OP KEEPS THE DEBUGGER HAPPY

READ:	MOV EAX,3      ; SPECIFY SYS_READ CALL
	MOV EBX,0      ; SPECIFY FILE DESCRIPTOR 0: STANDARD INPUT
	MOV ECX,BUFF   ; PASS OFFSET OF THE BUFFER TO READ TO
	MOV EDX,1      ; TELL SYS_READ TO READ ONE CHAR FROM STDIN
	INT 80H        ; CALL SYS_READ

	CMP EAX,0	; LOOK AT SYS_READ'S RETURN VALUE IN EAX
	JE EXIT		; JUMP IF EQUAL TO 0 (0 MEANS EOF) TO EXIT
			; OR FALL THROUGH TO TEST FOR LOWERCASE
	CMP BYTE [BUFF],61H  ; TEST INPUT CHAR AGAINST LOWERCASE 'A'
	JB WRITE	; IF BELOW 'A' IN ASCII CHART, NOT LOWERCASE
	CMP BYTE [BUFF],7AH  ; TEST INPUT CHAR AGAINST LOWERCASE 'Z'
	JA WRITE	; IF ABOVE 'Z' IN ASCII CHART, NOT LOWERCASE
			; AT THIS POINT, WE HAVE A LOWERCASE CHARACTER
	SUB BYTE [BUFF],20H  ; SUBTRACT 20H FROM LOWERCASE TO GIVE UPPERCASE...
			; ...AND THEN WRITE OUT THE CHAR TO STDOUT
WRITE:  MOV EAX,4	; SPECIFY SYS_WRITE CALL
	MOV EBX,1	; SPECIFY FILE DESCRIPTOR 1: STANDARD OUTPUT
	MOV ECX,BUFF	; PASS ADDRESS OF THE CHARACTER TO WRITE
	MOV EDX,1	; PASS NUMBER OF CHARS TO WRITE
	INT 80H		; CALL SYS_WRITE...
	JMP READ	; ...THEN GO TO THE BEGINNING TO GET ANOTHER CHARACTER

EXIT:	MOV EAX,1	; CODE FOR EXIT SYSCALL
	MOV EBX,0	; RETURN A CODE OF ZERO TO LINUX
	INT 80H		; MAKE KERNEL CALL TO EXIT PROGRAM
